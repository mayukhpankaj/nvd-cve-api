import requests
import csv
from datetime import datetime, timedelta
import os
import time
import re



CSV_file_str = ''

start_date= "2010-01-01T00:00:00.000"

PROCESSED_FILE = "last_fetch_datetime.txt"

def get_latest_fetch_datetime():
    if os.path.exists(PROCESSED_FILE):
        with open(PROCESSED_FILE, "r") as file:
            # last_fetch_datetime_str = file.read().strip()
            # # ftdate = datetime.strptime(last_fetch_datetime_str, "%Y-%m-%dT%H:%M:%S.%fZ")
            # parsed_datetime = datetime.strptime(last_fetch_datetime_str, "%Y-%m-%dT%H:%M:%S.%fZ")
            # formatted_datetime_str = parsed_datetime.strftime("%Y-%m-%dT%H:%M:%S.%f%z")
            # formatted_datetime_str = formatted_datetime_str[:-3] + "%2B01:00"
            # print(formatted_datetime_str)

            last_fetch_datetime_str = file.read().strip()


            return last_fetch_datetime_str
    return None


def fetch_cve_data(start_date=None, end_date=None):
    # api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0?lastModStartDate=2022-12-01T13:00:00.000%2B01:00&lastModEndDate=2024-02-10T13:36:00.000%2B01:00"


    # start_date = "2023-03-01T00:00:00.000%2B01:00"  
    # end_date = "2023-06-01T00:00:00.000%2B01:00"

    # start_date = "2020-10-01T00:00:00.000"  
    # end_date =   "2020-12-31T00:00:00.000"

    api_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate={start_date}&pubEndDate={end_date}"
    # api_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?lastModStartDate={start_date}&lastModEndDate={end_date}"
    
    # 2024-02-10T13:36:00.000%2B01:00
    # 2022-12-23T05:17:23.164%2B01:00
    
    cve_data = []
    page_size = 2000
    total_results = 1
    start_index = 0

    ctr =0;

    while start_index < total_results:

        ctr +=1

        params = {
            "startIndex": start_index,
            "resultsPerPage": page_size
        }
        
        print('making api call')
        response = requests.get(api_url, params=params)



        print(f"The current index while fetching the data from CVE API is: {start_index}")

        print(response.headers)

        if response.status_code == 200:
           
            results = response.json()
            total_results = results['totalResults']

            print("Total results ->",total_results)
            print("starting index ->",start_index)


            cve_items = results["vulnerabilities"]
            if not cve_items:
                break
            cve_data += cve_items
            start_index += page_size

            print('waiting before another api call ..')
            time.sleep(60)
        else:
            print(f"Failed to fetch data for start index -Restart {response.headers}.")
            print(response.reason)
            print(response.status_code)
            print(response._content)
            exit()

    return cve_data


def extract_desired_fields(cve_data):
    extracted_data = []
    max_length = 60

    print('extracting data ..')

    for cve_item in cve_data:
        if "API" in cve_item["cve"]["descriptions"][0]["value"] or "api" in cve_item["cve"]["descriptions"][0]["value"]:
            cve = cve_item['cve'].get('id', '')
            print(cve)
            description = cve_item["cve"]["descriptions"][0]["value"]
            title = str(cve)+': '
            title += (description[:max_length] + '..') if len(description) > max_length else description
            slug = str(cve)+' '
            slug  += (description[:45]) if len(description) > 45 else description
            slug = re.sub(r'[^a-zA-Z0-9\s]', '', slug).replace(' ', '-')

            user_interaction = 'NONE'
            confidentiality = 'NONE'
            integrity = 'NONE'
            availability = 'NONE'
            attack_vector = 'NONE'
            attack_complexity = 'NONE'
            weaknesses = 'NONE'

            if "cvssMetricV2" in cve_item["cve"]["metrics"]:
                base_score = cve_item["cve"]["metrics"]["cvssMetricV2"][0]["cvssData"].get("baseScore",'')
                severity = cve_item["cve"]["metrics"]["cvssMetricV2"][0].get('baseSeverity','')
                impact_score = cve_item["cve"]["metrics"]["cvssMetricV2"][0].get('impactScore','')
                exploit_score = cve_item["cve"]["metrics"]["cvssMetricV2"][0].get('exploitabilityScore','')
                user_bool = cve_item["cve"]["metrics"]["cvssMetricV2"][0].get("userInteractionRequired",False)
                
                user_interaction = "REQUIRED" if user_bool else "NONE"

                # print(type(user_bool))

                confidentiality  = cve_item["cve"]["metrics"]["cvssMetricV2"][0]["cvssData"].get('confidentialityImpact','')
                integrity  = cve_item["cve"]["metrics"]["cvssMetricV2"][0]["cvssData"].get('integrityImpact','')
                availability  = cve_item["cve"]["metrics"]["cvssMetricV2"][0]["cvssData"].get('availabilityImpact','')
                attack_vector =  cve_item["cve"]["metrics"]["cvssMetricV2"][0]["cvssData"].get('accessVector','')
                attack_complexity = cve_item["cve"]["metrics"]["cvssMetricV2"][0]["cvssData"].get('accessComplexity','')
            
            if 'weaknesses' in cve_item["cve"]:
                weaknesses = cve_item["cve"]["weaknesses"][0]['description'][0].get('value','')



            products_affected = []

            firstflag = True

            if 'configurations' in cve_item['cve']:
                for configuration in cve_item['cve'].get("configurations", []):
                    for node in configuration.get("nodes", []):
                        for cpe_match in node.get("cpeMatch", []):
                            criteria = cpe_match.get("criteria")
                            if criteria is not None:
                                products_affected.append(criteria)
                                if firstflag:
                                    vendorstr = criteria
                                    firstflag = False

            vendorparts = vendorstr.split(':')
            vendor = vendorparts[3]

            products_affected_html = "<ul>"

            for product in products_affected:
                product_parts = product.split(':')
                v = product_parts[3]
                p = product_parts[4]
                ver = product_parts[5]
                products_affected_html += f"<li><p><a href='https://www.akto.io/cves/vendor/{v}'><strong> {v} </strong></a> » <strong>{p}</strong> » <strong> {ver} </strong>  </li>"

            products_affected_html += '</ul>'






            urls = []

            url_html = "<ul>"

            for urlitem in cve_item["cve"]["references"]:
                if "url" in urlitem:
                    urls.append(urlitem['url'])

            only_url = urls 

            for url in urls:
                url_html += f"<li><p><a href='{url}' rel='noopener noreferrer nofollow' target='_blank'>{url}</a></p> </li>"

            url_html += "</ul>"

            nvdlink = 'https://nvd.nist.gov/vuln/detail/'+cve



            privilegesRequired = 'NONE'
            scope = 'NA'

            metrics = cve_item['cve']['metrics']

            if "cvssMetricV31" in metrics:
                privilegesRequired = metrics['cvssMetricV31'][0]["cvssData"]['privilegesRequired']
                scope = metrics['cvssMetricV31'][0]["cvssData"]['scope']
                base_score = metrics['cvssMetricV31'][0]["cvssData"]['baseScore']
                severity = metrics['cvssMetricV31'][0]["cvssData"]['baseSeverity'] 
                impact_score =  metrics['cvssMetricV31'][0]['impactScore']
                exploit_score =  metrics['cvssMetricV31'][0]['exploitabilityScore']
            elif "cvssMetricV30" in metrics:
                privilegesRequired = metrics['cvssMetricV30'][0]["cvssData"]['privilegesRequired']
                scope = metrics['cvssMetricV30'][0]["cvssData"]['scope']
                base_score = metrics['cvssMetricV30'][0]["cvssData"]['baseScore']
                severity = metrics['cvssMetricV30'][0]["cvssData"]['baseSeverity']
                impact_score =  metrics['cvssMetricV30'][0]['impactScore']
                exploit_score =  metrics['cvssMetricV30'][0]['exploitabilityScore']

            last_modified_date = datetime.strptime(cve_item['cve']["lastModified"], "%Y-%m-%dT%H:%M:%S.%f")
            published = datetime.strptime(cve_item['cve']["published"], "%Y-%m-%dT%H:%M:%S.%f")
            extracted_data.append((cve, description,title,vendor, slug,base_score,severity,impact_score,exploit_score,user_interaction,confidentiality,integrity,availability,attack_vector,attack_complexity,weaknesses,nvdlink,privilegesRequired,scope, url_html, products_affected_html, published, last_modified_date))
            # print('extraction complete ..')
    return extracted_data


def save_to_csv(extracted_data):
    global CSV_file_str
    CSV_file_str = start_date[:-13]+'.csv'
    with open(CSV_file_str, "w", newline="", encoding="utf-8") as csv_file:
        writer = csv.writer(csv_file)
        writer.writerow(["CVE ID", "Description", "title", "vendor", "slug", "base_score", "severity","impact_score","exploit_score","user_interaction","confidentiality","integrity","availability","attack_vector","attack_complexity", "Weakness","nvdlink","privilegesRequired","scope", "url_html", "products_affected_html", "Published Date", "Last Modified Date"])
        writer.writerows(extracted_data)


def save_latest_fetch_datetime(datetime_obj):
    global start_date
    with open(PROCESSED_FILE, "w") as file:
        file.write(start_date)


def main():
    # if os.path.exists(CSV_file_str):
    #     # The data present in this file will be overridden.
    #     print(f"File {CSV_file_str} already exists.")
    #     print("Remove this file and run the script again.")
    #     exit()

    # latest_fetch_datetime = get_latest_fetch_datetime()

    # end_date=datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
    # end_date = datetime.strptime(end_date, "%Y-%m-%dT%H:%M:%S.%fZ")
    # end_date = end_date.strftime("%Y-%m-%dT%H:%M:%S.%f%z")
    # end_date = end_date[:-3] + "%2B01:00"

    # print(end_date)

    global start_date

    start_date = get_latest_fetch_datetime()




    start_date_obj = datetime.strptime(start_date, "%Y-%m-%dT%H:%M:%S.%f")

    # Add 120 days to the start date
    new_date = start_date_obj + timedelta(days=90)
    # Format the new date in the desired format
    new_date_str = new_date.strftime("%Y-%m-%dT%H:%M:%S.%f")

    end_date = new_date_str[:-3]

    print(start_date)
    print(end_date)

    x = 1;

    iterations = 8

    while (x<=iterations):
        # if latest_fetch_datetime:
        #     cve_data = fetch_cve_data(start_date=latest_fetch_datetime, end_date=end_date)

        x = x+1

        if end_date:
            cve_data = fetch_cve_data(start_date=start_date, end_date=end_date)
        else:
            cve_data = fetch_cve_data()

        if cve_data == []:
            # print(f"\nNo new release after the previous fetch at: {latest_fetch_datetime}")
            print("no new data")
        else:
            extracted_data = extract_desired_fields(cve_data)
            if extracted_data == []:
                print("\nNo API related CVE found in any of the new release.")
            else:
                save_to_csv(extracted_data)
                latest_datetime_now = datetime.now()
                save_latest_fetch_datetime(latest_datetime_now)
                print(f"\nCVE data has been fetched and saved to {CSV_file_str}.")
        
        start_date = end_date

        start_date_obj = datetime.strptime(start_date, "%Y-%m-%dT%H:%M:%S.%f")

        # Add 120 days to the start date
        new_date = start_date_obj + timedelta(days=30)
        # Format the new date in the desired format
        new_date_str = new_date.strftime("%Y-%m-%dT%H:%M:%S.%f")

        end_date = new_date_str[:-3]



    print("****************Script Executed Successfully***************")


if __name__ == "__main__":
    main()
